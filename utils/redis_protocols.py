"""Protocol definitions for async Redis operations.

These protocols define the Redis interface used by SessionStore and CheckpointStore.
This allows type checking without tight coupling to redis-py, and enables easy
mocking in tests.

redis-py uses union return types (e.g., Awaitable[T] | T) to support both sync and
async clients, which makes strict Protocol matching difficult. We use permissive
types (Any, Awaitable[Any]) to work around this.
"""

from collections.abc import Awaitable
from typing import Any, Protocol


class AsyncRedisPipeline(Protocol):
    """Protocol for async Redis pipeline operations."""

    def hset(
        self,
        name: str,
        key: str | None = None,
        value: str | None = None,
        mapping: dict[str, str] | None = None,
    ) -> Any: ...
    def hgetall(self, name: str) -> Any: ...
    def hdel(self, name: str, *keys: str) -> Any: ...
    def sadd(self, name: str, *values: str) -> Any: ...
    def zadd(self, name: str, mapping: dict[str, float]) -> Any: ...
    def expire(self, name: str, time: int) -> Any: ...
    def delete(self, *names: str) -> Any: ...
    def srem(self, name: str, *values: str) -> Any: ...
    def zrem(self, name: str, *values: str) -> Any: ...
    async def execute(self) -> list[Any]: ...


class AsyncRedisClient(Protocol):
    """Protocol for async Redis client operations."""

    def pipeline(self) -> AsyncRedisPipeline: ...
    def hgetall(self, name: str) -> Awaitable[dict[Any, Any]]: ...
    def hget(self, name: str, key: str) -> Awaitable[Any]: ...
    def hset(
        self,
        name: str,
        key: str | None = None,
        value: str | None = None,
        mapping: dict[str, str] | None = None,
    ) -> Awaitable[int]: ...
    def hdel(self, name: str, *keys: str) -> Awaitable[int]: ...
    def smembers(self, name: str) -> Awaitable[set[Any]]: ...
    def exists(self, *names: str) -> Awaitable[int]: ...
    def ttl(self, name: str) -> Awaitable[int]: ...
    def delete(self, *names: str) -> Awaitable[int]: ...
    def zrangebyscore(
        self, name: str, min: float, max: float
    ) -> Awaitable[list[Any]]: ...
